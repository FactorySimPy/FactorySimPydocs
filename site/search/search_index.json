{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Extended resources for FactorySimPy","text":"<p>Welcome to the extended resources documentation for FactorySimPy!</p>"},{"location":"#reservablepriorityreqstore","title":"ReservablePriorityReqStore","text":"<p>The ReservablePriorityReqStore\u00a0is a class derived from SimPy's Store class that addresses a missing capability in the library by allowing both priority-based retrieval and reservation of items(or space) before they are actually retrieved (or put), respecting the capacity of the store. This is particularly useful in manufacturing systems where materials or products must be allocated in advance, ensuring that specific parts are reserved for machines before processing begins. It also allows priority-based retrieval, ensuring that urgent requests are handled first. Additionally, decoupling reservation from yielding a \"get\" request ensures that items remain in storage until they are actually needed, improving coordination in assembly lines and buffer management. Unlike SimPy\u2019s existing resource reservation methods, which manage process-related elements like machines or operators, ReservablePriorityReqStore focuses on item-level management, making it a valuable addition for handling inventory, buffer stocks, and material flows in discrete-event simulations. However, when implementhing SimPy interrupts, the events should be manually cancelled incase of an interruption.</p> <p>The <code>ReservablePriorityReqStore</code> extends SimPy's <code>Store</code> by allowing users to:  </p> <ul> <li> <p>Reserve Capacity: Processes can reserve space (or item) in the store before actual put (or get) in it.  </p> </li> <li> <p>Enforce Reservation Rules: Prohibits any process from adding (or getting) items to the store without a prior reservation.  </p> </li> <li> <p>Priority for requests: Users can pass a priority along with the reservation requests. The requests with the highest priority(lowest first) will be yielded first. Two requests with same priority will be yielded in a FIFO manner.</p> </li> <li> <p>Cancel a reservation: Allows users to cancel a placed/yielded reserve_put (or reserve_get) request.</p> </li> </ul>"},{"location":"#parameters","title":"Parameters","text":"<ul> <li><code>env</code>: The SimPy environment managing the simulation.  </li> <li><code>capacity</code>: Maximum number of items the store can hold (default: infinite).  </li> </ul>"},{"location":"#example-usage","title":"Example Usage","text":"<pre><code>import simpy\nimport random\nfrom ReservablePriorityReqStore import ReservablePriorityReqStore\n\nclass Item:\n    \"\"\"Represents an item to be stored.\"\"\"\n    def __init__(self, name):\n        self.name = name\n\n# Simulation Setup\nenv = simpy.Environment()\nitemstore = ReservablePriorityReqStore(env, capacity=3)\n\ndef producer(env, itemstore, name, priority):\n    \"\"\"Producer process produces items and puts it in the store.\"\"\"\n    yield env.timeout(random.uniform(1, 3))  # Simulate time before producing\n\n    put_reservation = itemstore.reserve_put(priority=priority)\n    yield put_reservation  # Wait for reservation to succeed\n\n    item = Item(f\"{name}\")\n    itemstore.put(put_reservation, item)\n    print(f\"T={env.now:.2f} : {name} added to store with priority {priority}\")\n\ndef consumer(env, itemstore, name, priority, cancel=False):\n    \"\"\"Consumer process picks up items from the store.\"\"\"\n\n    get_reservation = itemstore.reserve_get(priority=priority)\n    print(f\"T={env.now:.2f} : {name} placed a reserve_get request \n             to store with priority {priority}\")\n\n    if cancel and random.choice([True, False]):\n        itemstore.reserve_get_cancel(get_reservation)\n        print(f\"T={env.now:.2f} : {name} CANCELED reservation\")\n        return\n\n    yield get_reservation  # Wait for reservation to succeed\n    print(f\"T={env.now:.2f} : {name} yielded from store with priority {priority}\")\n    yield env.timeout(random.uniform(2, 5))\n    item = itemstore.get(get_reservation)\n    print(f\"T={env.now:.2f} : {name} retrieved {item.name} from store with \n                priority {priority}\")\n\n# Creating producers and consumers\nenv.process(consumer(env, itemstore, \"Consumer1\", priority=3, cancel=True))\nenv.process(consumer(env, itemstore, \"Consumer2\", priority=1))\nenv.process(consumer(env, itemstore, \"Consumer3\", priority=2))\n\n\nenv.process(producer(env, itemstore, \"ItemA\", priority=2))\nenv.process(producer(env, itemstore, \"ItemB\", priority=1))\nenv.process(producer(env, itemstore, \"ItemC\", priority=3))\n\n\nenv.run(until=10)\n</code></pre> <p>Simulation output <pre><code>T=0.00 : Consumer1 placed a reserve_get request to store with priority 3\nT=0.00 : Consumer1 CANCELED reservation\nT=0.00 : Consumer2 placed a reserve_get request to store with priority 1\nT=0.00 : Consumer3 placed a reserve_get request to store with priority 2\nT=2.14 : ItemB added to store with priority 1\nT=2.14 : Consumer2 yielded from store with priority 1\nT=2.23 : ItemA added to store with priority 2\nT=2.23 : Consumer3 yielded from store with priority 2\nT=2.54 : ItemC added to store with priority 3\nT=5.40 : Consumer2 retrieved ItemB from store with priority 1\nT=6.02 : Consumer3 retrieved ItemA from store with priority 2 \n</code></pre></p>"},{"location":"#usecase","title":"Usecase","text":"<pre><code># @title Usecase\nimport simpy\nfrom ReservablePriorityReqStore import ReservablePriorityReqStore\n\n'''\nIn this simulation, two machines (MachineGreen and MachineOrange) produce\nnew items by consuming specific part. MachineGreen,which produces green balls, \nrequests parts (like yellow and blue balls) with a higher priority, while \nMachineOrange, which produces orange balls, requests parts\n(like yellow and red balls) with lower priority. Producers generate red, yellow, \nand blue balls at defined intervals, and consumers retrieve the assembled green \nand orange balls from their respective stores.'''\n\n\n\n# ----- Producer -----\ndef producer(env, interarrival, store, item_prefix):\n    \"\"\"Produces items with a given prefix into a store.\"\"\"\n    i = 0\n    while True:\n        yield env.timeout(interarrival)\n        put_req = store.reserve_put()\n        yield put_req\n        item_name = f\"{item_prefix}{i+1}\"\n        store.put(put_req, item_name)\n        print(f\"T={env.now:.2f}: Producer {item_prefix}: added {item_name} \n                   (store size={len(store.items)})\")\n\n        i += 1\n\n# ----- Consumer -----\ndef consumer(env, interarrival, store, consumer_name):\n    \"\"\"Consumes items from a store.\"\"\"\n    while True:\n        yield env.timeout(interarrival)\n        get_req = store.reserve_get()\n        yield get_req\n        item = store.get(get_req)\n        print(f\"T={env.now:.2f}: Consumer {consumer_name}: got item {item}\")\n\n\n# ----- Machine -----\ndef machine(env, delay, input_stores, input_priorities, \n               output_store, output_prefix):\n    \"\"\"\n    A machine that requests multiple items from input stores \n    (with optional priorities),waits processing time, and outputs a new item.\n\n    Args:\n        input_stores (list): list of stores to get inputs from\n        input_priorities (list): list of priorities (None if no priority)\n        output_store: where to put output\n        output_prefix: name prefix for output items\n    \"\"\"\n    i = 0\n    while True:\n        put_req = output_store.reserve_put()\n        yield put_req\n\n        # Request input items\n        input_requests = []\n        for store, priority in zip(input_stores, input_priorities):\n            if priority is not None:\n                req = store.reserve_get(priority=priority)\n            else:\n                req = store.reserve_get()\n            input_requests.append(req)\n\n        print(f\"T={env.now:.2f}: Machine {output_prefix}: waiting to yield \n                           reserve_get requests\")\n        yield env.all_of(input_requests)\n\n        # Get input items\n        for store, req in zip(input_stores, input_requests):\n            store.get(req)\n\n        print(f\"T={env.now:.2f}: Machine {output_prefix}: got both inputs\")\n        yield env.timeout(delay)\n\n        output_store.put(put_req, f\"{output_prefix}{i}\")\n        print(f\"T={env.now:.2f}: Machine {output_prefix}: finished product is \n                        available in its store\")\n        i += 1\n\n# ----- Simulation Setup -----\ndef run_simulation():\n    env = simpy.Environment()\n\n    # Create Stores\n    redstore = ReservablePriorityReqStore(env, capacity=5)\n    yellowstore = ReservablePriorityReqStore(env, capacity=1)\n    bluestore = ReservablePriorityReqStore(env, capacity=5)\n    orangestore = ReservablePriorityReqStore(env, capacity=1)\n    greenstore = ReservablePriorityReqStore(env, capacity=1)\n\n    # Producer setups\n    producer_params = [\n        (1, redstore, \"red\"),\n        (2, yellowstore, \"yellow\"),\n        (1, bluestore, \"blue\")\n    ]\n\n    # Consumer setups\n    consumer_params = [\n        (1, orangestore, \"orange\"),\n        (1, greenstore, \"green\")\n    ]\n\n    # Machine setups\n    machine_params = [\n       (1, [yellowstore, redstore], [None, None], orangestore, \"orange\"),#Machine1\n       (1, [yellowstore, bluestore], [-2, None], greenstore, \"green\") # Machine2\n    ]\n\n    # Start Producers\n    for interarrival, store, prefix in producer_params:\n        env.process(producer(env, interarrival, store, prefix))\n\n    # Start Consumers\n    for interarrival, store, name in consumer_params:\n        env.process(consumer(env, interarrival, store, name))\n\n    # Start Machines\n    for delay, inputs, priorities, output, prefix in machine_params:\n        env.process(machine(env, delay, inputs, priorities, output, prefix))\n\n    # Run Simulation\n    env.run(until=5)\n\n\n\n# Run it\nrun_simulation()\n</code></pre> <p>Simulation output </p> <pre><code>T=0.00: Machine orange: waiting to yield reserve_get requests\nT=0.00: Machine green: waiting to yield reserve_get requests\nT=1.00: Producer red: added red1 (store size=1)\nT=1.00: Producer blue: added blue1 (store size=1)\nT=2.00: Producer yellow: added yellow1 (store size=1)\nT=2.00: Producer red: added red2 (store size=2)\nT=2.00: Producer blue: added blue2 (store size=2)\nT=2.00: Machine green: got both inputs\nT=3.00: Machine green: finished product is available in its store\nT=3.00: Producer red: added red3 (store size=3)\nT=3.00: Producer blue: added blue3 (store size=2)\nT=3.00: Consumer green: got item green0\nT=3.00: Machine green: waiting to yield reserve_get requests\nT=4.00: Producer yellow: added yellow2 (store size=1)\nT=4.00: Producer red: added red4 (store size=4)\nT=4.00: Producer blue: added blue4 (store size=3)\nT=4.00: Machine green: got both inputs\n</code></pre> <p>Go to API Reference</p>"},{"location":"#priorityreqstore","title":"PriorityReqStore","text":"<p>PriorityReqStore is a resource store with basic priority handling capabilities. Users can add a priority for each of the get(or put) requests. Request with lower values of priority yields first. If two requests with same priority are placed from two processes then FIFO order is followed to yield the requests.</p> <p>Main Features:</p> <ul> <li>Priority for requests: Manages concurrent requests with different priority values.</li> </ul>"},{"location":"#parameters_1","title":"Parameters","text":"<ul> <li><code>env</code>: The SimPy environment managing the simulation.  </li> <li><code>capacity</code>: Maximum number of items the store can hold (default: infinite).  </li> </ul>"},{"location":"#example-usage_1","title":"Example Usage","text":"<pre><code>import simpy\nfrom PriorityReqStore import PriorityReqStore\n\nclass item:\n  def __init__(self,name):\n    self.name=name\n\ndef source(name,env,delay,priority=0):\n    i=1\n\n    yield env.timeout(delay)\n    item1 = item(name='item'+str(name)+str(i))\n    print(f'T={env.now:.2f}: Source {name} Going to put an item in \n                    store {item1.name} with priority {priority}')\n\n    yield store.put(item1,priority)\n    i+=2\ndef sink(name,env,delay,priority):\n\n    yield env.timeout(delay)\n    print(f'T={env.now:.2f}: Sink {name} placed a get request with \n                     priority {priority} in the store')\n    item = yield store.get(priority)\n    print(f'T={env.now:.2f}: Sink {name} Got an item from store {item.name}')\n\n\n\nenv= simpy.Environment()\nstore= PriorityReqStore(env,2)\n\np1= env.process(sink('OUT-1',env,0,2))\np2= env.process(sink('OUT-2',env,0,1))\np3= env.process(source('IN-A',env,1,2))\np4= env.process(source('IN-B',env,1,1))\n\nenv.run(until=5)\n</code></pre> <p>Simulation output <pre><code>T=0.00: Sink OUT-1 placed a get request with priority 2 in the store\nT=0.00: Sink OUT-2 placed a get request with priority 1 in the store\nT=1.00: Source IN-A Going to put an item in store itemIN-A1 with priority 2\nT=1.00: Source IN-B Going to put an item in store itemIN-B1 with priority 1\nT=1.00: Sink OUT-2 Got an item from store itemIN-A1\nT=1.00: Sink OUT-1 Got an item from store itemIN-B1\n</code></pre></p>"},{"location":"#usecase_1","title":"Usecase","text":"<pre><code>'''\nA university\u2019s Central IT Department supports Admin, Library, Student Labs,\nand Research Labs. Departments request IT systems (computers). Systems are\nallocated based on request priority \u2014 higher-priority departments get\nsystems first.'''\n\n\nimport simpy\nfrom PriorityReqStore import PriorityReqStore  # Importing your PriorityReqStore\n\nclass CentralITDepartment:\n    def __init__(self, env, initial_stock=0):\n        self.env = env\n        self.store = PriorityReqStore(env)\n        self.results = []\n\n        # Pre-load some stock if needed\n        for i in range(initial_stock):\n            self.store.items.append(f\"Preloaded_System_{i+1}\")\n\n    def department_request(self, department_name, priority):\n        \"\"\"Department places a request for a system.\"\"\"\n        print(f\"T={self.env.now:.2f}: {department_name} places a request with \n                                 priority {priority}\")\n        system = yield self.store.get(priority=priority)\n        self.results.append((self.env.now, department_name, system))\n        print(f\"T={self.env.now:.2f}: {department_name} received {system}\")\n\n    def add_systems(self, count, delay=0):\n        \"\"\"IT department adds systems after a delay.\"\"\"\n        yield self.env.timeout(delay)\n        for i in range(count):\n            system_name = f\"System_{i+1}_after_delay\"\n            yield self.store.put(system_name)\n            print(f\"T={self.env.now:.2f}: IT Department added {system_name}\")\n\ndef run_central_it_simulation():\n    env = simpy.Environment()\n    it_department = CentralITDepartment(env)\n\n    # Start departments making requests\n    env.process(it_department.department_request('Admin', priority=3))\n    env.process(it_department.department_request('Library', priority=3))\n    env.process(it_department.department_request('Student Lab', priority=1))\n    env.process(it_department.department_request('Research Lab', priority=2))\n\n    # IT Department will add new systems after 2 time units\n    env.process(it_department.add_systems(count=3, delay=2))\n\n    env.run(until=10)\n\n\nif __name__ == \"__main__\":\n    run_central_it_simulation()\n</code></pre> <p>Simulation output <pre><code>T=0.00: Admin places a request with priority 3\nT=0.00: Library places a request with priority 3\nT=0.00: Student Lab places a request with priority 1\nT=0.00: Research Lab places a request with priority 2\nT=2.00: IT Department added System_1_after_delay\nT=2.00: Student Lab received System_1_after_delay\nT=2.00: IT Department added System_2_after_delay\nT=2.00: Research Lab received System_2_after_delay\nT=2.00: IT Department added System_3_after_delay\nT=2.00: Admin received System_3_after_delay\n</code></pre></p> <p>Go to API Reference</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#ReservablePriorityReqStore.ReservablePriorityReqStore","title":"<code>ReservablePriorityReqStore.ReservablePriorityReqStore</code>","text":"<p>               Bases: <code>Store</code></p> <p>This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access.</p> <p>Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority.</p> <p>get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for <code>reserve_put</code> and <code>reserve_get</code> operations to ensures that only processes with valid reservations can store or retrieve items.</p> <p>ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order.</p> <p>It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled.</p> <p>Attributes:</p> Name Type Description <code>reserved_events</code> <code>list</code> <p>Maintains events corresponding to reserved items to preserve item order by index</p> <code>reserve_put_queue</code> <code>list</code> <p>Queue for managing reserve_put reservations</p> <code>reservations_put</code> <code>list</code> <p>List of successful put reservations</p> <code>reserve_get_queue(list)</code> <code>list</code> <p>Queue for managing reserve_get reservations</p> <code>reservations_get(list)</code> <code>list</code> <p>List of successful get reservations</p>"},{"location":"api/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_put","title":"<code>reserve_put(priority=0)</code>","text":"<p>Create a reservation request to put an item into the store.</p> <p>This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to <code>reserve_put_queue</code>, which is maintained in priority order.</p> <p>After adding the event to the queue, <code>_trigger_reserve_put</code> is called to process any pending reservations.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority level of the reservation request.                       Lower values indicate higher priority. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <p>simpy.Event: A reservation event that will succeed when space is available.</p>"},{"location":"api/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_put_cancel","title":"<code>reserve_put_cancel(put_event_to_cancel)</code>","text":"<p>Cancel a previously made <code>reserve_put</code> request.</p> <p>This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the <code>reserve_put_queue</code>, it is removed before triggering <code>_trigger_reserve_put</code> to process any pending reservations. If the reservation is already in <code>reservations_put</code>, it is also removed and <code>_trigger_reserve_put</code> is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>put_event_to_cancel</code> <code>Event</code> <p>The reservation event that needs to be canceled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the reservation was successfully canceled.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the specified event does not exist in <code>reserve_put_queue</code>           or <code>reservations_put</code>.</p>"},{"location":"api/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_get_cancel","title":"<code>reserve_get_cancel(get_event_to_cancel)</code>","text":"<p>Cancel a previously made <code>reserve_get</code> request.</p> <p>This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the <code>reserve_get_queue</code>, it is removed, and <code>_trigger_reserve_get()</code> is called to process any remaining reservations.</p> <p>If the reservation is already in <code>reservations_get</code>, it is removed, and the corresponding item is repositioned in the store to maintain order. <code>_trigger_reserve_get()</code> is then triggered to handle pending reservations.</p> <p>Parameters:</p> Name Type Description Default <code>get_event_to_cancel</code> <code>Event</code> <p>The reservation event that needs to be canceled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the reservation was successfully canceled.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the specified event does not exist in <code>reserve_get_queue</code>           or <code>reservations_get</code>.</p>"},{"location":"api/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_get","title":"<code>reserve_get(priority=0)</code>","text":"<p>Create a reservation request to retrieve an item from the store.</p> <p>This method generates a SimPy event representing a request to reserve an item for retrieval (<code>get</code>). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request.</p> <p>The event is then added to <code>reserve_get_queue</code>, which is maintained in priority order, and <code>_trigger_reserve_get()</code> is called to process pending reservations if items are available.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority level of the reservation request.                       Lower values indicate higher priority. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <p>simpy.Event: A reservation event that will succeed when an item becomes available.</p>"},{"location":"api/#ReservablePriorityReqStore.ReservablePriorityReqStore.get","title":"<code>get(get_event)</code>","text":"<p>Retrieve an item from the store after a successful reservation.</p> <p>This method attempts to retrieve an item associated with a <code>reserve_get</code> event. If the reservation exists, it triggers <code>_trigger_get</code> to retrieve the item. If successful, <code>_trigger_reserve_put</code> is called to process any pending <code>reserve_put</code> requests. If the item retrieval fails, an error message is raised.</p> <p>Parameters:</p> Name Type Description Default <code>get_event</code> <code>Event</code> <p>The reservation event associated with the request.</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>The retrieved item if successful, otherwise raises an error</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no reservations are available in the reservations_get</p> <code>RuntimeError</code> <p>If item returned is None</p>"},{"location":"api/#ReservablePriorityReqStore.ReservablePriorityReqStore.put","title":"<code>put(put_event, item)</code>","text":"<p>Perform a <code>put</code> operation on the store and trigger any pending <code>reserve_get</code> requests.</p> <p>Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers <code>_trigger_reserve_get</code> to process pending get requests.</p> <p>Parameters:</p> Name Type Description Default <code>put_event</code> <code>Event</code> <p>The event corresponding to the reservation.</p> required <code>item</code> <code>object</code> <p>The item to be added to the store.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the put operation succeeded, False otherwise.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no reservations are available in the reservations_put</p> <code>RuntimeError</code> <p>If proceed is False after put operation</p>"},{"location":"api/#PriorityReqStore.PriorityReqStore","title":"<code>PriorityReqStore.PriorityReqStore</code>","text":"<p>               Bases: <code>Store</code></p> <p>This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based store for processes for item put and get.</p> <p>Processes can pass a priority as argument in the put and get request. Lower values indicate higher priority. If two processes have the same priority, the one that requested first will be served first.</p>"},{"location":"api/#PriorityReqStore.PriorityReqStore.get","title":"<code>get = BoundClass(PriorityGet)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>yields a get request with the given priority.</p>"},{"location":"api/#PriorityReqStore.PriorityReqStore.put","title":"<code>put = BoundClass(PriorityPut)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>yields a put request with the given priority</p>"},{"location":"priorityreqstore/","title":"API Reference","text":""},{"location":"priorityreqstore/#PriorityReqStore.PriorityReqStore","title":"<code>PriorityReqStore.PriorityReqStore</code>","text":"<p>               Bases: <code>Store</code></p> <p>This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based store for processes for item put and get.</p> <p>Processes can pass a priority as argument in the put and get request. Lower values indicate higher priority. If two processes have the same priority, the one that requested first will be served first.</p>"},{"location":"priorityreqstore/#PriorityReqStore.PriorityReqStore.get","title":"<code>get = BoundClass(PriorityGet)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>yields a get request with the given priority.</p>"},{"location":"priorityreqstore/#PriorityReqStore.PriorityReqStore.put","title":"<code>put = BoundClass(PriorityPut)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>yields a put request with the given priority</p>"},{"location":"reservablepriorityreqstore/","title":"API Reference","text":""},{"location":"reservablepriorityreqstore/#ReservablePriorityReqStore.ReservablePriorityReqStore","title":"<code>ReservablePriorityReqStore.ReservablePriorityReqStore</code>","text":"<p>               Bases: <code>Store</code></p> <p>This is a class that is derived from SimPy's Store class and has extra capabilities that makes it a priority-based reservable store for processes to reserve space for storing and retrieving items with priority-based access.</p> <p>Processes can use reserve_put() and reserve_get() methods to get notified when a space becomes available in the store or when an item gets available in the ReservablePriorityReqStore. These methods returns a unique event (SimPy.Event) to the process for every reserve requests it makes. Processes can also pass a priority as argument in the request. Lower values indicate higher priority.</p> <p>get and put are two methods that can be used for item storing and retrieval from ReservablePriorityReqStore. Process has to make a prior reservation and pass the associated reservation event as argument in the get and put requests. ReservablePriorityReqStore maintains separate queues for <code>reserve_put</code> and <code>reserve_get</code> operations to ensures that only processes with valid reservations can store or retrieve items.</p> <p>ReservablePriorityReqStore preserves item order by associating an unreserved item in the store with a reservation event by index when a reserve_get() request is made. As a result, it maintains a list of reserved events to preserve item order.</p> <p>It also allows users to cancel an already placed reserve_get or reserve_put request even if it is yielded. It also handles the dissociation of the event and item done at the time of reservation when an already yielded event is canceled.</p> <p>Attributes:</p> Name Type Description <code>reserved_events</code> <code>list</code> <p>Maintains events corresponding to reserved items to preserve item order by index</p> <code>reserve_put_queue</code> <code>list</code> <p>Queue for managing reserve_put reservations</p> <code>reservations_put</code> <code>list</code> <p>List of successful put reservations</p> <code>reserve_get_queue(list)</code> <code>list</code> <p>Queue for managing reserve_get reservations</p> <code>reservations_get(list)</code> <code>list</code> <p>List of successful get reservations</p>"},{"location":"reservablepriorityreqstore/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_put","title":"<code>reserve_put(priority=0)</code>","text":"<p>Create a reservation request to put an item into the store.</p> <p>This function generates a SimPy event representing a reservation request. The event is assigned attributes such as priority, resource name, and the process making the request. The event is then added to <code>reserve_put_queue</code>, which is maintained in priority order.</p> <p>After adding the event to the queue, <code>_trigger_reserve_put</code> is called to process any pending reservations.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority level of the reservation request.                       Lower values indicate higher priority. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <p>simpy.Event: A reservation event that will succeed when space is available.</p>"},{"location":"reservablepriorityreqstore/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_put_cancel","title":"<code>reserve_put_cancel(put_event_to_cancel)</code>","text":"<p>Cancel a previously made <code>reserve_put</code> request.</p> <p>This method allows a process to cancel its reservation for putting an item into the store. If the reservation exists in the <code>reserve_put_queue</code>, it is removed before triggering <code>_trigger_reserve_put</code> to process any pending reservations. If the reservation is already in <code>reservations_put</code>, it is also removed and <code>_trigger_reserve_put</code> is triggered.</p> <p>Parameters:</p> Name Type Description Default <code>put_event_to_cancel</code> <code>Event</code> <p>The reservation event that needs to be canceled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the reservation was successfully canceled.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the specified event does not exist in <code>reserve_put_queue</code>           or <code>reservations_put</code>.</p>"},{"location":"reservablepriorityreqstore/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_get_cancel","title":"<code>reserve_get_cancel(get_event_to_cancel)</code>","text":"<p>Cancel a previously made <code>reserve_get</code> request.</p> <p>This method allows a process to cancel its reservation for retrieving an item from the store. If the reservation exists in the <code>reserve_get_queue</code>, it is removed, and <code>_trigger_reserve_get()</code> is called to process any remaining reservations.</p> <p>If the reservation is already in <code>reservations_get</code>, it is removed, and the corresponding item is repositioned in the store to maintain order. <code>_trigger_reserve_get()</code> is then triggered to handle pending reservations.</p> <p>Parameters:</p> Name Type Description Default <code>get_event_to_cancel</code> <code>Event</code> <p>The reservation event that needs to be canceled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the reservation was successfully canceled.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the specified event does not exist in <code>reserve_get_queue</code>           or <code>reservations_get</code>.</p>"},{"location":"reservablepriorityreqstore/#ReservablePriorityReqStore.ReservablePriorityReqStore.reserve_get","title":"<code>reserve_get(priority=0)</code>","text":"<p>Create a reservation request to retrieve an item from the store.</p> <p>This method generates a SimPy event representing a request to reserve an item for retrieval (<code>get</code>). The event is assigned attributes such as priority, the resource it belongs to, and the process making the request.</p> <p>The event is then added to <code>reserve_get_queue</code>, which is maintained in priority order, and <code>_trigger_reserve_get()</code> is called to process pending reservations if items are available.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>The priority level of the reservation request.                       Lower values indicate higher priority. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <p>simpy.Event: A reservation event that will succeed when an item becomes available.</p>"},{"location":"reservablepriorityreqstore/#ReservablePriorityReqStore.ReservablePriorityReqStore.get","title":"<code>get(get_event)</code>","text":"<p>Retrieve an item from the store after a successful reservation.</p> <p>This method attempts to retrieve an item associated with a <code>reserve_get</code> event. If the reservation exists, it triggers <code>_trigger_get</code> to retrieve the item. If successful, <code>_trigger_reserve_put</code> is called to process any pending <code>reserve_put</code> requests. If the item retrieval fails, an error message is raised.</p> <p>Parameters:</p> Name Type Description Default <code>get_event</code> <code>Event</code> <p>The reservation event associated with the request.</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>The retrieved item if successful, otherwise raises an error</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no reservations are available in the reservations_get</p> <code>RuntimeError</code> <p>If item returned is None</p>"},{"location":"reservablepriorityreqstore/#ReservablePriorityReqStore.ReservablePriorityReqStore.put","title":"<code>put(put_event, item)</code>","text":"<p>Perform a <code>put</code> operation on the store and trigger any pending <code>reserve_get</code> requests.</p> <p>Ensures that only processes with a valid reservation can put items into the store. If the put operation succeeds, it triggers <code>_trigger_reserve_get</code> to process pending get requests.</p> <p>Parameters:</p> Name Type Description Default <code>put_event</code> <code>Event</code> <p>The event corresponding to the reservation.</p> required <code>item</code> <code>object</code> <p>The item to be added to the store.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the put operation succeeded, False otherwise.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no reservations are available in the reservations_put</p> <code>RuntimeError</code> <p>If proceed is False after put operation</p>"}]}